{"version":3,"file":"js/../js/utils.js","mappings":"0CA8FA,SAASA,EAAkBC,GACvB,MAAwB,iBAAVA,GAAsBA,GAAS,KAAOA,EAAQ,G,uFA5E5D,EAAAC,OASJ,SAAgBC,GACZ,OAAO,SAAUC,GACb,OAAIA,EACO,SAAUC,EAAKC,EAASC,GAC3B,MAAMC,EAAQH,EAAII,QAClB,GAAIN,EAAME,GAAK,EAAOE,GAAM,CACxB,GAAIH,EAAKC,EAAKC,GACV,OAAO,EAEXD,EAAIK,QAAQF,KAIjBL,IArBX,EAAAQ,SAyBJ,MAKIC,YAAmBC,EAA2BC,GAA3B,KAAAD,OAAAA,EAA2B,KAAAC,QAAAA,EAF9C,KAAAC,MAAgB,GAChB,KAAAC,SAAU,EAEN,IAAIC,EAAQ,EAEZC,KAAKC,MAAQN,EAAOI,GACpBG,OAAOC,iBAAiBH,KAAM,CAC1BD,MAAO,CACHK,IAAG,IAAYL,EACfM,IAAIC,GACAP,EAAQO,EACRN,KAAKC,MAAQD,KAAKL,OAAOI,OAKzCR,QACI,MAAO,CAACS,KAAKD,MAAOC,KAAKH,MAAMU,QAEnCf,SAASO,EAAOQ,IACZP,KAAKD,MAAQA,EACbC,KAAKH,MAAMU,OAASA,EAExBrB,OACI,MAAM,MAAEa,EAAK,OAAEJ,GAAWK,KAI1B,OAHIL,EAAOY,OAASR,IAChBC,KAAKD,MAAQA,EAAQ,GAElBA,EAEXS,OACI,MAAMT,EAAQC,KAAKD,MAInB,OAHIA,EAAQ,IACRC,KAAKD,MAAQA,EAAQ,GAElBA,EAEXU,aAAaV,GAAgB,GACzB,OAAOA,EAAQC,KAAKD,MAExBW,UAAUtB,EAAkBuB,GACxB,OAAQvB,GAAWY,KAAKD,OAASC,KAAKL,OAAOY,OAASI,IAvE1D,EAAAC,SAgFJ,SAAkBjB,GACd,IAAII,EAAQ,EACRhB,EAAQY,EAAOI,GACnB,MAAMc,EAA0B,CAAC9B,EAAOA,GAExC,GACIA,EAAQY,EAAOI,GACVjB,EAAkBC,GAGvB8B,EAAMd,GAAS,GAAKhB,EAEpBgB,GAAS,EACLA,EAAQ,EAAIJ,EAAOY,SACa,MAA5BZ,EAAOI,EAAQ,GAAGhB,QAGlB8B,EAAMd,GAAS,GAAKe,OAAOC,yBAG9BhB,EAAQJ,EAAOY,QAExB,OAAOM,I","sources":["webpack://vdsor/./js/utils.ts"],"sourcesContent":["\r\n\r\ntype IMatchFunc = (env: MatchEnv, isFinal: boolean, arg?: any) => boolean | void;\r\n/**\r\n * 0 为 DATA_TYPES_MARK 标记或者任意匹配字符串解析数据\r\n * 1 为 data types 的 key 值，或者匹配目标字符串\r\n * 2 为匹配目标的结束下标\r\n */\r\ntype IFound = Array<[any, string, number]>;\r\n\r\ntype IWalker = (next: IMatchFunc) => IMatchFunc;\r\n\r\ninterface IPattern {\r\n    match?: IMatchFunc,\r\n    walker: IWalker\r\n}\r\n\r\nexport {\r\n    getRange,\r\n    walker,\r\n    MatchEnv,\r\n    IPattern,\r\n    IFound,\r\n    IMatchFunc,\r\n    IWalker\r\n}\r\n\r\n\r\nfunction walker(match: IMatchFunc) {\r\n    return function (next: IMatchFunc): IMatchFunc {\r\n        if (next) {\r\n            return function (env, isFinal, arg) {\r\n                const state = env.store();\r\n                if (match(env, false, arg)) {\r\n                    if (next(env, isFinal)) {\r\n                        return true;\r\n                    }\r\n                    env.restore(state);\r\n                }\r\n            };\r\n        }\r\n        return match;\r\n    }\r\n}\r\n\r\nclass MatchEnv {\r\n    index: number;\r\n    token: any;\r\n    found: IFound = [];\r\n    success = false;\r\n    constructor(public tokens: Array<any>, public pattern?: IPattern) {\r\n        let index = 0;\r\n\r\n        this.token = tokens[index];\r\n        Object.defineProperties(this, {\r\n            index: {\r\n                get() { return index; },\r\n                set(val: number) {\r\n                    index = val;\r\n                    this.token = this.tokens[index];\r\n                }\r\n            }\r\n        });\r\n    }\r\n    store(): [number, number] {\r\n        return [this.index, this.found.length];\r\n    }\r\n    restore([index, length]: [number, number]) {\r\n        this.index = index;\r\n        this.found.length = length;\r\n    }\r\n    next() {\r\n        const { index, tokens } = this;\r\n        if (tokens.length > index) {\r\n            this.index = index + 1;\r\n        }\r\n        return index;\r\n    }\r\n    prev() {\r\n        const index = this.index;\r\n        if (index > 0) {  // 会使 token = undefined\r\n            this.index = index - 1;\r\n        }\r\n        return index;\r\n    }\r\n    compareIndex(index: number = -1) {\r\n        return index - this.index;\r\n    }\r\n    isSuccess(isFinal: boolean, offset: number) {\r\n        return !isFinal || this.index >= this.tokens.length - offset;\r\n    }\r\n}\r\n\r\n\r\nfunction isPositiveInteger(value: number) {\r\n    return typeof value === \"number\" && value >= 0 && !(value % 1);\r\n}\r\n\r\nfunction getRange(tokens: Array<any>) {\r\n    let index = 0;\r\n    let value = tokens[index];\r\n    const range: [number, number] = [value, value];\r\n\r\n    do {\r\n        value = tokens[index];\r\n        if (!isPositiveInteger(value)) {\r\n            debugger;\r\n        }\r\n        range[index >> 1] = value;\r\n\r\n        index += 2;\r\n        if (index - 1 < tokens.length) {\r\n            if (tokens[index - 1].value !== \",\") {\r\n                debugger;\r\n            } else {\r\n                range[index >> 1] = Number.MAX_SAFE_INTEGER;\r\n            }\r\n        }\r\n    } while (index < tokens.length)\r\n\r\n    return range;\r\n}\r\n"],"names":["isPositiveInteger","value","walker","match","next","env","isFinal","arg","state","store","restore","MatchEnv","constructor","tokens","pattern","found","success","index","this","token","Object","defineProperties","get","set","val","length","prev","compareIndex","isSuccess","offset","getRange","range","Number","MAX_SAFE_INTEGER"],"sourceRoot":""}