{"version":3,"file":"js/../js/utils.js","mappings":"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","sources":["webpack://vdsor/./js/utils.ts"],"sourcesContent":["\r\n\r\ntype IMatchFunc = (env: MatchEnv, isFinal: boolean, arg?: any) => boolean | void;\r\ntype IFound = Array<[any, string, number]>;\r\n\r\ntype IWalker = (next: IMatchFunc) => IMatchFunc;\r\n\r\ninterface IPattern {\r\n    match?: IMatchFunc,\r\n    walker: IWalker\r\n}\r\n\r\nexport {\r\n    getRange,\r\n    walker,\r\n    MatchEnv,\r\n    IPattern,\r\n    IFound,\r\n    IMatchFunc,\r\n    IWalker,\r\n    matchUnits,\r\n    matchManyTimes,\r\n}\r\nfunction matchUnits(next: IMatchFunc, patterns: Array<IPattern>, useMatchAll: boolean): IMatchFunc {\r\n\r\n    const matches = patterns.map(pattern => pattern.walker(null));\r\n    const indexs = matches.map((_, index) => index);\r\n\r\n    const comMatches = next && patterns.map(pattern => pattern.walker(next));\r\n\r\n    return function (env: MatchEnv, isFinal: boolean) {\r\n        let maxIndex: number;\r\n        let maxRecord: IFound;\r\n        const res = env.found;\r\n        env.found = [];\r\n\r\n        walk(indexs);\r\n        env.found = res;\r\n        if (maxRecord) {\r\n            res.push(...maxRecord);\r\n            env.index = maxIndex;\r\n            return true;\r\n        }\r\n\r\n        function walk(indexs: Array<number>) {\r\n            const state = env.store();\r\n            const length = indexs.length;\r\n            for (let i = 0; i < length; i += 1) {\r\n                const index = indexs[i];\r\n\r\n                if (!matches[index](env, false)) {\r\n                    continue;\r\n                }\r\n                if (length > 1 && walk(indexs.slice(0, i).concat(indexs.slice(i + 1)))) {\r\n                    return true;\r\n                }\r\n\r\n                if ((useMatchAll && length > 1)) {\r\n                    env.restore(state);\r\n                    continue;\r\n                }\r\n                if (comMatches || isFinal) {\r\n                    env.restore(state);\r\n                    if (!(comMatches || matches)[index](env, isFinal)) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (env.compareIndex(maxIndex) < 0) {\r\n                    maxRecord = env.found.slice();\r\n                    maxIndex = env.index;\r\n                    if (env.isSuccess(true, 0)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                env.restore(state);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction matchManyTimes(\r\n    next: IMatchFunc,\r\n    pattern: IPattern,\r\n    min: number,\r\n    max: number,\r\n    nonGreedy?: boolean\r\n): IMatchFunc {\r\n    const match = pattern.walker(null);\r\n\r\n    if (next) {\r\n        const comMatch = pattern.walker(next);\r\n\r\n        return !nonGreedy\r\n            ? function (env, isFinal) {\r\n\r\n                return walk(0);\r\n\r\n                function walk(step: number) {\r\n                    const state = env.store();\r\n                    if (step < max) {\r\n                        if (match(env, false)) {\r\n                            if (\r\n                                walk(step + 1)\r\n                                || (\r\n                                    env.restore(state)\r\n                                    , step >= min - 1\r\n                                    && comMatch(env, isFinal)\r\n                                )\r\n                            ) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (step >= min && next(env, isFinal)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            : function (env, isFinal) {\r\n                if (min <= 0 && next(env, isFinal)) {\r\n                    return true;\r\n                }\r\n                if (max > 0) {\r\n                    const state = env.store();\r\n                    let step = 1;\r\n                    while (true) {\r\n                        if (step >= min && comMatch(env, isFinal)) {\r\n                            return true;\r\n                        }\r\n                        if (++step > max || !match(env, false)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    env.restore(state);\r\n                }\r\n            }\r\n    } else {\r\n        return function (env, isFinal) {\r\n            return walk(0);\r\n\r\n            function walk(step: number) {\r\n                if (step < max) {\r\n                    const state = env.store();\r\n                    if (match(env, false)) {\r\n                        if (\r\n                            walk(step + 1)\r\n                            || (\r\n                                env.restore(state),\r\n                                isFinal\r\n                                && step >= min - 1\r\n                                && match(env, true)\r\n                            )\r\n                        ) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                if (step >= min && env.isSuccess(isFinal, 0)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nfunction walker(match: IMatchFunc) {\r\n    return function (next: IMatchFunc): IMatchFunc {\r\n        if (next) {\r\n            return function (env, isFinal, arg) {\r\n                const state = env.store();\r\n                if (match(env, false, arg)) {\r\n                    if (next(env, isFinal)) {\r\n                        return true;\r\n                    }\r\n                    env.restore(state);\r\n                }\r\n            };\r\n        }\r\n        return match;\r\n    }\r\n}\r\n\r\nclass MatchEnv {\r\n    index: number;\r\n    token: any;\r\n    found: IFound = [];\r\n    success = false;\r\n    constructor(public tokens: Array<any>, public pattern?: IPattern) {\r\n        let index = 0;\r\n\r\n        this.token = tokens[index];\r\n        Object.defineProperties(this, {\r\n            index: {\r\n                get() { return index; },\r\n                set(val: number) {\r\n                    index = val;\r\n                    this.token = this.tokens[index];\r\n                }\r\n            }\r\n        });\r\n    }\r\n    store(): [number, number] {\r\n        return [this.index, this.found.length];\r\n    }\r\n    restore([index, length]: [number, number]) {\r\n        this.index = index;\r\n        this.found.length = length;\r\n    }\r\n    next() {\r\n        const { index, tokens } = this;\r\n        if (tokens.length > index) {\r\n            this.index = index + 1;\r\n        }\r\n        return index;\r\n    }\r\n    prev() {\r\n        const index = this.index;\r\n        if (index > 0) {  // 会使 token = undefined\r\n            this.index = index - 1;\r\n        }\r\n        return index;\r\n    }\r\n    compareIndex(index: number = -1) {\r\n        return index - this.index;\r\n    }\r\n    isSuccess(isFinal: boolean, offset: number) {\r\n        return !isFinal || this.index >= this.tokens.length - offset;\r\n    }\r\n}\r\n\r\n\r\nfunction isPositiveInteger(value: number) {\r\n    return typeof value === \"number\" && value >= 0 && !(value % 1);\r\n}\r\n\r\nfunction getRange(tokens: Array<any>) {\r\n    let index = 0;\r\n    let value = tokens[index];\r\n    const range: [number, number] = [value, value];\r\n\r\n    do {\r\n        value = tokens[index];\r\n        if (!isPositiveInteger(value)) {\r\n            debugger;\r\n        }\r\n        range[index >> 1] = value;\r\n\r\n        index += 2;\r\n        if (index - 1 < tokens.length) {\r\n            if (tokens[index - 1].value !== \",\") {\r\n                debugger;\r\n            } else {\r\n                range[index >> 1] = Number.MAX_SAFE_INTEGER;\r\n            }\r\n        }\r\n    } while (index < tokens.length)\r\n\r\n    return range;\r\n}\r\n"],"names":["isPositiveInteger","value","matchUnits","next","patterns","useMatchAll","matches","map","pattern","walker","indexs","_","index","comMatches","env","isFinal","maxIndex","maxRecord","res","found","walk","state","store","length","i","slice","concat","restore","compareIndex","isSuccess","push","matchManyTimes","min","max","nonGreedy","match","comMatch","step","arg","MatchEnv","constructor","tokens","success","this","token","Object","defineProperties","get","set","val","prev","offset","getRange","range","Number","MAX_SAFE_INTEGER"],"sourceRoot":""}